<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
    </head>

    <body>
        <!--这是我们的View-->
        <div id="app">
            {{ message }}<!--文本插值-->
        </div>
    </body>
    <script src="js/vue.js"></script>
    <script>
        // 这是我们的Model
        var exampleData = {
            message: 'Hello World!'
        }

        // 创建一个 Vue 实例或 "ViewModel"
        // 它连接 View 与 Model
        let app = new Vue({
            //在创建Vue实例时，需要传入一个选项对象，选项对象可以包含数据、挂载元素、方法、模生命周期钩子等等。
            
            //选项对象的el属性指向View，el: '#app'表示该Vue实例将挂载到<div id="app">...</div>这个元素
            el: '#app',
            //data: exampleData表示我们的Model是exampleData对象。
            data: exampleData
        })

//数据与方法
        var data ={a:1}
        var vm = new Vue({
            data:data
        })
        // 获得这个实例上的属性
        // 返回源数据中对应的字段
        console.log(vm.a==data.a)//true

        // 设置属性也会影响到原始数据
        vm.a = 2
        console.log(data.a) // => 2

        // ……反之亦然
        data.a = 3
        console.log(vm.a) // => 3
        //当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 data 中存在的属性才是响应式的。
        
        //使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再_追踪_变化。
        var obj = {
          foo: 'bar'
        }

        Object.freeze(obj)

        new Vue({
          el: '#app',
          data: obj
        })


        //除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。
        var data = { a: 1 }
        var vm = new Vue({
          el: '#example',
          data: data
        })

        vm.$data === data // => true
        vm.$el === document.getElementById('example') // => true

        // $watch 是一个实例方法
        vm.$watch('a', function (newValue, oldValue) {
          // 这个回调将在 `vm.a` 改变后调用
        })

//实例生命周期钩子
        //每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。
        //
        
        //比如 created 钩子可以用来在一个实例被创建之后执行代码：
        
        new Vue({
            data: {
                a: 1
              },
            created: function () {
                // `this` 指向 vm 实例
                console.log('a is: ' + this.a)
              }
        })
        // => "a is: 1"
        //也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。
        //不要在选项属性或回调上使用箭头函数
        </script>    

<!--模板语法-->
        <!--双大括号的文本插值-->
        <span>Message: {{ msg }}</span>

        <span v-once>这个将不会改变: {{ msg }}</span>

         <!--v-html 指令：-->
        <p>Using mustaches: {{ rawHtml }}</p>
        <p>Using v-html directive: <span v-html="rawHtml"></span></p>
        <!--Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令-->
        <div v-bind:id="dynamicId"></div>

<!--使用 JavaScript 表达式,有个限制就是，每个绑定都只能包含单个表达式-->
        {{ number + 1 }}

        {{ ok ? 'YES' : 'NO' }}

        {{ message.split('').reverse().join('') }}

        <div v-bind:id="'list-' + id"></div>

        <!-- 这是语句，不是表达式 -->
        {{ var a = 1 }}

        <!-- 流控制也不会生效，请使用三元表达式 -->
        {{ if (ok) { return message } }}

<!--指令:带有 v- 前缀的特殊属性-->
        <!--指令参数-->
        <!--v-bind 指令可以用于响应式地更新 HTML 属性：-->
        <a v-bind:href="url">...</a>


        <!--v-on 指令，它用于监听 DOM 事件：-->
        <a v-on:click="doSomething">...</a>

        <!--指令修饰符:. 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用event.preventDefault() -->
        <form v-on:submit.prevent="onSubmit">...</form>

<!--缩写:Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：-->
        <!--v-bind 缩写-->
        <!-- 完整语法 -->
        <a v-bind:href="url">...</a>

        <!-- 缩写 -->
        <a :href="url">...</a>

        <!--v-on 缩写-->
        <!-- 完整语法 -->
        <a v-on:click="doSomething">...</a>

        <!-- 缩写 -->
        <a @click="doSomething">...</a>

<!--计算属性:对于任何复杂逻辑，你都应当使用计算属性。-->
        <div id="example">
            <p>Original message: "{{ message }}"</p>
            <p>Computed reversed message: "{{ reversedMessage }}"</p>
        </div>

        <script>
            var vm1 = new Vue({
                el: '#example',
                data: {
                    message: 'Hello'
                  },
                computed: {
                    // 计算属性的 getter
                    reversedMessage: function () {
                      // `this` 指向 vm 实例
                        return this.message.split('').reverse().join('')
                    }
                  }
                })
        </script>

<!--计算属性缓存 vs 方法-->


        </script>
        <p>Reversed message: "{{ reversedMessage() }}"</p>
        <script>
            // 在组件中
            methods: {
              reversedMessage: function () {
                return this.message.split('').reverse().join('')
              }
            }
            //我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
            //相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
            //我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。
        </script>
<!--计算属性 vs 侦听属性-->

<!--侦听器:watch -->

        <div id="watch-example">
          <p>
            Ask a yes/no question:
            <input v-model="question">
          </p>
          <p>{{ answer }}</p>
        </div>

        <!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
        <!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
        <script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
        <script>
        var watchExampleVM = new Vue({
          el: '#watch-example',
          data: {
            question: '',
            answer: 'I cannot give you an answer until you ask a question!'
          },
          watch: {
            // 如果 `question` 发生改变，这个函数就会运行
            question: function (newQuestion, oldQuestion) {
              this.answer = 'Waiting for you to stop typing...'
              this.getAnswer()
            }
          },
          methods: {
            // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
            // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
            // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
            // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
            // 请参考：https://lodash.com/docs#debounce
            getAnswer: _.debounce(
              function () {
                if (this.question.indexOf('?') === -1) {
                  this.answer = 'Questions usually contain a question mark. ;-)'
                  return
                }
                this.answer = 'Thinking...'
                var vm = this
                axios.get('https://yesno.wtf/api')
                  .then(function (response) {
                    vm.answer = _.capitalize(response.data.answer)
                  })
                  .catch(function (error) {
                    vm.answer = 'Error! Could not reach the API. ' + error
                  })
              },
              // 这是我们为判定用户停止输入等待的毫秒数
              500
            )
          }
        })


        Vue.component('example', {
		  props: {
		    // 基础类型检测 (`null` 指允许任何类型)
		    propA: Number,
		    // 可能是多种类型
		    propB: [String, Number],
		    // 必传且是字符串
		    propC: {
		      type: String,
		      required: true
		    },
		    // 数值且有默认值
		    propD: {
		      type: Number,
		      default: 100
		    },
		    // 数组/对象的默认值应当由一个工厂函数返回
		    propE: {
		      type: Object,
		      default: function () {
		        return { message: 'hello' }
		      }
		    },
		    // 自定义验证函数
		    propF: {
		      validator: function (value) {
		        return value > 10
		      }
		    }
		  }
		})

		
        </script>

<!--Class 与 Style 绑定-->

</html>